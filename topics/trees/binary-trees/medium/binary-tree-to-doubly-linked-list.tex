% \question We are given a binary tree and we want to convert it into a doubly linked list in place (no new data structures created).\newline\newline
% \begin{solution}[1in]
% \textbf{Intuition}\newline
% If we find the correct order traversal for the binary tree, we can manipulate the pointers and create a doubly linked list in place.\newline
% \textbf{Algorithm}\newline
% We first do a depth first search and store the traveresal order in a list. \newline
% After, we iterate through the list and set all the node pointers correctly. \newline
% \begin{lstlisting}
% /**
%  * Input :
%           1
%         /   \
%       2     5
%       /  \     \
%      3    4      6
%  * Output: 
%  * -> 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 6 <-
%  */
% import java.utils.*;

% public Node treeToDoubleLL(Node s) {
%     if (s == null) {
%         return;
%     }

%     // Obtain traversal in order
%     ArrayList<Node> traversal = new ArrayList<Node>();
%     inorder(s, traversal);

%     // Set everyone except for first and last node
%     for (int i = 1; i < traversal.length - 1; i++) {
%         Node cur = traversal.get(i);
%         Node prev = traversal.get(i - 1);
%         Node next = traversal.get(i + 1);
%         cur.left = prev;
%         cur.right = next;
%     }

%     Node first = traversal.get(0);
%     // Set the first and last node
%     if (traversal.length > 1) {
%         Node last = traversal.get(traversal.length - 1);

%         first.left = traversal.get(1);
%         first.right = last;
%         last.left = traversal.get(traversal.length - 2);
%         last.right = first;
%     } else {
%         first.left = first;
%         first.right = first;
%     }
% }

% void inorder(Node s, ArrayList<Node> traversal) {
%     if (s == null) {
%         return;
%     }
%     inorder(s.left, traversal);
%     traversal.add(s);
%     inorder(s.right, traversal);
% }
% \end{lstlisting}
% \end{solution}