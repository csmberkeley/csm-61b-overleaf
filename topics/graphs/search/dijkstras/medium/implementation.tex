\question Implement dijkstra's (shortest paths from a given node) given the following skeleton code. Your solution may use less lines than what are provided.\\

Treat $G$ as an edge adjacency list where every index represents the list of tuples representing edges connected to the vertex represented by that index. The first element of each tuple represents the other vertex that edge is connected to, and the second element represents the weight of said edge.\\

Further suppose that a class $minheap$ is implemented and has the following methods: $minheap.heapify(int[] keylist)$, $minheap.removemin()$, $minheap.keychange(int value, int newkey)$, and $minheap.length()$

\begin{lstlisting}
public int[] dijkstras(G, s){

    ________________________ = _________________________;
    
    int[] __________________ = _________________________;
    
    int[] __________________ = _________________________;
    
    for (__________________________________) {
    
        _____________________ = __________________________;

        _____________________ = __________________________;
    }
    _____________________ = __________________________;
    
    _____________________ = __________________________;
    
    while _____________________________________ {
    
        _____________________ = __________________________;
        
        for (________________________________________) {
        
            ___________________ = ________________________;
            
            if (_________________________________________){
            
               ________________ = ________________________;
               
               ________________ = ________________________;
               
               ___________________________________________;
            }
        }
    }
    ______________________________________________________;
}
\end{lstlisting}

\begin{solution}
\begin{lstlisting}
public int[] dijkstras(G, s){
    n = G.length();
    int[] dist = new int[n];
    int[] prev = new int[n];
    for (v = 0; v < n; v++) {
        dist[v] = Integer.MAX_VALUE;
        prev[v] = -1;
    }
    dist[s] = 0;
    heap = minheap.heapify(dist);
    while (heap.length() > 0) {
        u = heap.removemin();
        for (edgeindex = 0; edgeindex < G[u].length(); edgeindex++) {
            v = G[u][edgeindex][0];
            if (dist[v] > dist[u] + G[u][edgeindex][1]){
                dist[v] = dist[u] + G[u][edgeindex][1];
                prev[v] = u;
                heap.keychange(v, dist[v]);
            }
        }
    }
    return prev;   
}
\end{lstlisting}
\end{solution}